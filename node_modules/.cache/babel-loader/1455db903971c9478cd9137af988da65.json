{"ast":null,"code":"export default {\n  props: {\n    marker: {\n      type: Object,\n      default: undefined\n    },\n    offsetX: {\n      type: Number,\n      default: 0\n    },\n    offsetY: {\n      type: Number,\n      default: 0\n    },\n    alignment: {\n      type: String,\n      default: \"top\"\n    },\n    zIndex: {\n      type: Number,\n      default: 50\n    },\n    cssPosition: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    onMap() {\n      const map = this.map;\n      const self = this;\n      class Overlay extends this.maps.OverlayView {\n        constructor(map) {\n          super();\n          this.setMap(map);\n          this.draw = () => this.repaint();\n          this.setPosition = () => this.repaint();\n        }\n        repaint() {\n          const div = self.$el;\n          const projection = this.getProjection();\n          if (projection && div) {\n            const posPixel = projection.fromLatLngToDivPixel(self.latLng);\n            let x, y;\n            switch (self.alignment) {\n              case \"top\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottom\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y;\n                break;\n              case \"left\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"right\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"center\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"topleft\":\n              case \"lefttop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"topright\":\n              case \"righttop\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottomleft\":\n              case \"leftop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y;\n                break;\n              case \"bottomright\":\n              case \"rightbottom\":\n                x = posPixel.x;\n                y = posPixel.y;\n                break;\n              default:\n                throw new Error(\"Invalid alignment type of custom marker!\");\n            }\n            if (self.cssPosition) {\n              div.style.transform = `translate(${x + self.offsetX}px, ${y + self.offsetY}px)`;\n            } else {\n              div.style.left = x + self.offsetX + \"px\";\n              div.style.top = y + self.offsetY + \"px\";\n            }\n            div.style[\"z-index\"] = self.zIndex;\n          }\n        }\n        onAdd() {\n          const div = self.$el;\n          const panes = this.getPanes();\n          div.style.position = \"absolute\";\n          div.style.display = \"inline-block\";\n          div.style.zIndex = self.zIndex;\n          panes.overlayLayer.appendChild(div);\n          panes.overlayMouseTarget.appendChild(div);\n          this.getDraggable = () => false;\n          this.getPosition = () => {\n            console.log('on get position', self.maps, self.lat, self.lng);\n            return new self.maps.LatLng(self.lat, self.lng);\n          };\n        }\n        onRemove() {\n          if (self.$el) {\n            const ua = window.navigator.userAgent;\n            const msie = ua.indexOf(\"MSIE \");\n            if (msie > 0 || !!ua.match(/Trident.*rv:11\\./)) {\n              self.$el.parentNode.removeChild(self.$el);\n            } else {\n              self.$el.remove();\n            }\n          }\n        }\n      }\n      this.$overlay = new Overlay(map);\n      setTimeout(() => {\n        if (this.$overlay) {\n          this.$overlay.repaint();\n          this.opacity = 1;\n        }\n      }, 100);\n    }\n  },\n  data() {\n    return {\n      opacity: 0.01\n    };\n  },\n  watch: {\n    maps() {\n      this.onMap();\n    },\n    marker: {\n      handler() {\n        if (this.$overlay) {\n          this.$overlay.setPosition();\n        }\n      },\n      deep: true\n    },\n    zIndex() {\n      if (this.$overlay) {\n        this.$overlay.repaint();\n      }\n    }\n  },\n  computed: {\n    maps() {\n      return this.$parent.api;\n    },\n    map() {\n      return this.$parent.map;\n    },\n    lat() {\n      return parseFloat(isNaN(this.marker.lat) ? this.marker.latitude : this.marker.lat);\n    },\n    lng() {\n      return parseFloat(isNaN(this.marker.lng) ? this.marker.longitude : this.marker.lng);\n    },\n    latLng() {\n      if (this.marker instanceof this.maps.LatLng) {\n        return this.marker;\n      }\n      return new this.maps.LatLng(this.lat, this.lng);\n    }\n  },\n  unmounted() {\n    if (this.$overlay) {\n      this.$overlay.setMap(null);\n      this.$overlay = undefined;\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["props","marker","type","Object","default","undefined","offsetX","Number","offsetY","alignment","String","zIndex","cssPosition","Boolean","methods","onMap","map","self","Overlay","maps","OverlayView","constructor","setMap","draw","repaint","setPosition","div","$el","projection","getProjection","posPixel","fromLatLngToDivPixel","latLng","x","y","offsetWidth","offsetHeight","Error","style","transform","left","top","onAdd","panes","getPanes","position","display","overlayLayer","appendChild","overlayMouseTarget","getDraggable","getPosition","console","log","lat","lng","LatLng","onRemove","ua","window","navigator","userAgent","msie","indexOf","match","parentNode","removeChild","remove","$overlay","setTimeout","opacity","data","watch","handler","deep","computed","$parent","api","parseFloat","isNaN","latitude","longitude","unmounted"],"sourceRoot":"","sources":["/Users/you/Desktop/work_dev/inso-frontend-master/node_modules/vue3-gmap-custom-marker/gmap-custom-marker.vue"],"sourcesContent":["<template>\n  <div :style=\"{opacity: opacity}\">\n    <slot/>\n  </div>\n</template>\n<script>\n\nexport default {\n  props: {\n    marker: {\n      type: Object,\n      default: undefined\n    },\n    offsetX: {\n      type: Number,\n      default: 0\n    },\n    offsetY: {\n      type: Number,\n      default: 0\n    },\n    alignment: {\n      type: String,\n      default: \"top\"\n    },\n    zIndex: {\n      type: Number,\n      default: 50\n    },\n    cssPosition: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    onMap() {\n      const map = this.map\n      const self = this\n\n      class Overlay extends this.maps.OverlayView {\n        constructor(map) {\n          super();\n          this.setMap(map);\n          this.draw = () => this.repaint();\n          this.setPosition = () => this.repaint();\n        }\n\n        repaint() {\n          const div = self.$el;\n          const projection = this.getProjection();\n          if (projection && div) {\n            const posPixel = projection.fromLatLngToDivPixel(self.latLng);\n            let x, y;\n            switch (self.alignment) {\n              case \"top\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottom\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y;\n                break;\n              case \"left\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"right\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"center\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"topleft\":\n              case \"lefttop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"topright\":\n              case \"righttop\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottomleft\":\n              case \"leftop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y;\n                break;\n              case \"bottomright\":\n              case \"rightbottom\":\n                x = posPixel.x;\n                y = posPixel.y;\n                break;\n              default:\n                throw new Error(\"Invalid alignment type of custom marker!\");\n            }\n            if (self.cssPosition) {\n              div.style.transform = `translate(${x + self.offsetX}px, ${y + self.offsetY}px)`;\n            } else {\n              div.style.left = x + self.offsetX + \"px\";\n              div.style.top = y + self.offsetY + \"px\";\n            }\n            div.style[\"z-index\"] = self.zIndex;\n          }\n        }\n\n        onAdd() {\n          const div = self.$el;\n          const panes = this.getPanes();\n          div.style.position = \"absolute\";\n          div.style.display = \"inline-block\";\n          div.style.zIndex = self.zIndex;\n          panes.overlayLayer.appendChild(div);\n          panes.overlayMouseTarget.appendChild(div);\n          this.getDraggable = () => false;\n          this.getPosition = () => {\n            console.log('on get position', self.maps, self.lat, self.lng)\n            return new self.maps.LatLng(self.lat, self.lng);\n          };\n        }\n\n        onRemove() {\n          if (self.$el) {\n            const ua = window.navigator.userAgent\n            const msie = ua.indexOf(\"MSIE \")\n            if (msie > 0 || !!ua.match(/Trident.*rv:11\\./)) {\n              self.$el.parentNode.removeChild(self.$el)\n            } else {\n              self.$el.remove();\n            }\n          }\n        }\n      }\n\n      this.$overlay = new Overlay(map);\n      setTimeout(() => {\n        if (this.$overlay) {\n          this.$overlay.repaint();\n          this.opacity = 1;\n        }\n      }, 100);\n    },\n  },\n  data() {\n    return {\n      opacity: 0.01\n    };\n  },\n  watch: {\n    maps() {\n      this.onMap()\n    },\n    marker: {\n      handler() {\n        if (this.$overlay) {\n          this.$overlay.setPosition()\n        }\n      },\n      deep: true\n    },\n    zIndex() {\n      if (this.$overlay) {\n        this.$overlay.repaint()\n      }\n    }\n  },\n  computed: {\n    maps() {\n      return this.$parent.api\n    },\n    map() {\n      return this.$parent.map\n    },\n    lat() {\n      return parseFloat(\n          isNaN(this.marker.lat) ? this.marker.latitude : this.marker.lat\n      );\n    },\n    lng() {\n      return parseFloat(\n          isNaN(this.marker.lng) ? this.marker.longitude : this.marker.lng\n      );\n    },\n    latLng() {\n      if (this.marker instanceof this.maps.LatLng) {\n        return this.marker;\n      }\n      return new this.maps.LatLng(this.lat, this.lng);\n    }\n  },\n  unmounted() {\n    if (this.$overlay) {\n      this.$overlay.setMap(null);\n      this.$overlay = undefined;\n    }\n  }\n};\n</script>"]},"metadata":{},"sourceType":"module"}