{"ast":null,"code":"import { renderSlot as _renderSlot, normalizeStyle as _normalizeStyle, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", {\n    style: _normalizeStyle({\n      opacity: $data.opacity\n    })\n  }, [_renderSlot(_ctx.$slots, \"default\")], 4);\n}","map":{"version":3,"mappings":";;uBACEA,oBAEM;IAFAC,KAAK;MAAAC,SAAYC;IAAO;MAC5BC,YAAOC","names":["_createElementBlock","style","opacity","$data","_renderSlot","_ctx"],"sourceRoot":"","sources":["/Users/you/Desktop/work_dev/inso-frontend-master/node_modules/vue3-gmap-custom-marker/gmap-custom-marker.vue"],"sourcesContent":["<template>\n  <div :style=\"{opacity: opacity}\">\n    <slot/>\n  </div>\n</template>\n<script>\n\nexport default {\n  props: {\n    marker: {\n      type: Object,\n      default: undefined\n    },\n    offsetX: {\n      type: Number,\n      default: 0\n    },\n    offsetY: {\n      type: Number,\n      default: 0\n    },\n    alignment: {\n      type: String,\n      default: \"top\"\n    },\n    zIndex: {\n      type: Number,\n      default: 50\n    },\n    cssPosition: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    onMap() {\n      const map = this.map\n      const self = this\n\n      class Overlay extends this.maps.OverlayView {\n        constructor(map) {\n          super();\n          this.setMap(map);\n          this.draw = () => this.repaint();\n          this.setPosition = () => this.repaint();\n        }\n\n        repaint() {\n          const div = self.$el;\n          const projection = this.getProjection();\n          if (projection && div) {\n            const posPixel = projection.fromLatLngToDivPixel(self.latLng);\n            let x, y;\n            switch (self.alignment) {\n              case \"top\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottom\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y;\n                break;\n              case \"left\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"right\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"center\":\n                x = posPixel.x - div.offsetWidth / 2;\n                y = posPixel.y - div.offsetHeight / 2;\n                break;\n              case \"topleft\":\n              case \"lefttop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"topright\":\n              case \"righttop\":\n                x = posPixel.x;\n                y = posPixel.y - div.offsetHeight;\n                break;\n              case \"bottomleft\":\n              case \"leftop\":\n                x = posPixel.x - div.offsetWidth;\n                y = posPixel.y;\n                break;\n              case \"bottomright\":\n              case \"rightbottom\":\n                x = posPixel.x;\n                y = posPixel.y;\n                break;\n              default:\n                throw new Error(\"Invalid alignment type of custom marker!\");\n            }\n            if (self.cssPosition) {\n              div.style.transform = `translate(${x + self.offsetX}px, ${y + self.offsetY}px)`;\n            } else {\n              div.style.left = x + self.offsetX + \"px\";\n              div.style.top = y + self.offsetY + \"px\";\n            }\n            div.style[\"z-index\"] = self.zIndex;\n          }\n        }\n\n        onAdd() {\n          const div = self.$el;\n          const panes = this.getPanes();\n          div.style.position = \"absolute\";\n          div.style.display = \"inline-block\";\n          div.style.zIndex = self.zIndex;\n          panes.overlayLayer.appendChild(div);\n          panes.overlayMouseTarget.appendChild(div);\n          this.getDraggable = () => false;\n          this.getPosition = () => {\n            console.log('on get position', self.maps, self.lat, self.lng)\n            return new self.maps.LatLng(self.lat, self.lng);\n          };\n        }\n\n        onRemove() {\n          if (self.$el) {\n            const ua = window.navigator.userAgent\n            const msie = ua.indexOf(\"MSIE \")\n            if (msie > 0 || !!ua.match(/Trident.*rv:11\\./)) {\n              self.$el.parentNode.removeChild(self.$el)\n            } else {\n              self.$el.remove();\n            }\n          }\n        }\n      }\n\n      this.$overlay = new Overlay(map);\n      setTimeout(() => {\n        if (this.$overlay) {\n          this.$overlay.repaint();\n          this.opacity = 1;\n        }\n      }, 100);\n    },\n  },\n  data() {\n    return {\n      opacity: 0.01\n    };\n  },\n  watch: {\n    maps() {\n      this.onMap()\n    },\n    marker: {\n      handler() {\n        if (this.$overlay) {\n          this.$overlay.setPosition()\n        }\n      },\n      deep: true\n    },\n    zIndex() {\n      if (this.$overlay) {\n        this.$overlay.repaint()\n      }\n    }\n  },\n  computed: {\n    maps() {\n      return this.$parent.api\n    },\n    map() {\n      return this.$parent.map\n    },\n    lat() {\n      return parseFloat(\n          isNaN(this.marker.lat) ? this.marker.latitude : this.marker.lat\n      );\n    },\n    lng() {\n      return parseFloat(\n          isNaN(this.marker.lng) ? this.marker.longitude : this.marker.lng\n      );\n    },\n    latLng() {\n      if (this.marker instanceof this.maps.LatLng) {\n        return this.marker;\n      }\n      return new this.maps.LatLng(this.lat, this.lng);\n    }\n  },\n  unmounted() {\n    if (this.$overlay) {\n      this.$overlay.setMap(null);\n      this.$overlay = undefined;\n    }\n  }\n};\n</script>"]},"metadata":{},"sourceType":"module"}